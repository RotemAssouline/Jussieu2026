<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>45-Second Clean Loop Animation</title>
    <style>
        body { margin: 0; padding: 0; background: transparent; overflow: hidden; }
        canvas { display: block; width: 100vw; height: 100vh; border: 0; margin: 0; background: #7FAEBA; }                                                                    </style>
</head>
<body>


    <canvas id="mainCanvas"></canvas>

    <script>
        const mainCanvas = document.getElementById('mainCanvas');
        const canvasContext = mainCanvas.getContext('2d');
        let canvasW = 0, canvasH = 0;
        function resizeCanvas() {
            const dpr = window.devicePixelRatio || 1;
            canvasW = window.innerWidth;
            canvasH = window.innerHeight;
            mainCanvas.width = Math.round(canvasW * dpr);
            mainCanvas.height = Math.round(canvasH * dpr);
            canvasContext.setTransform(dpr, 0, 0, dpr, 0, 0);

            // Enable anti-aliasing for smoother rendering
            canvasContext.imageSmoothingEnabled = true;
            canvasContext.imageSmoothingQuality = 'high';
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        let activeParticles = [];
        let isAnimationRunning = false;
        let animationBeginTime = 0;
        let animationDurationMs = 45000; // 45 seconds total
        let cloudsSpawned = 0;
        const cloudSchedule = [0, 10000, 20000, 30000];
        // Enhanced vector field computation
        function computeFieldVector(xPos, yPos) {
            const constantFieldX = 1.0;
            const constantFieldY = 1.0;

            // Enhanced perturbations with 1.5x multiplier
            let perturbX = 1.5 * (0.3 * Math.sin(0.01 * xPos) * Math.cos(0.008 * yPos) +
                                 0.2 * Math.cos(0.012 * xPos + 0.006 * yPos));

            let perturbY = 1.5 * (0.25 * Math.cos(0.009 * xPos) * Math.sin(0.011 * yPos) +
                                 0.25 * Math.sin(0.007 * xPos - 0.013 * yPos));

            // Enforce perturbation magnitude limit of 0.75
            const perturbationSize = Math.sqrt(perturbX * perturbX + perturbY * perturbY);
            if (perturbationSize > 0.75) {
                const normalizationFactor = 0.75 / perturbationSize;
                perturbX *= normalizationFactor;
                perturbY *= normalizationFactor;
            }

            return {
                x: constantFieldX + perturbX,
                y: constantFieldY + perturbY
            };
        }

        class FlowingParticle {
            constructor(startX, startY) {
                this.xPosition = startX;
                this.yPosition = startY;
                this.prevX = startX;
                this.prevY = startY;
                this.particleSize = 2;
            }

            updateParticle() {
                // Store previous position for line drawing
                this.prevX = this.xPosition;
                this.prevY = this.yPosition;

                const fieldValue = computeFieldVector(this.xPosition, this.yPosition);
                const flowSpeed = 2;

                this.xPosition += fieldValue.x * flowSpeed * 2;
                this.yPosition += fieldValue.y * flowSpeed * 2;

                // Keep particle if within extended boundary
                return this.xPosition >= -1000 && this.xPosition <= canvasW + 1000 &&
                       this.yPosition >= -1000 && this.yPosition <= canvasH + 1000;
            }

            renderParticle() {
                // Draw line from previous to current position (creates trail effect)
                canvasContext.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                canvasContext.lineWidth = 2;
                canvasContext.lineCap = 'round';
                canvasContext.lineJoin = 'round';
                canvasContext.beginPath();
                canvasContext.moveTo(this.prevX, this.prevY);
                canvasContext.lineTo(this.xPosition, this.yPosition);
                canvasContext.stroke();

                // Draw the particle dot
                canvasContext.fillStyle = 'rgba(255, 255, 255, 0.9)';
                canvasContext.beginPath();
                canvasContext.arc(this.xPosition, this.yPosition, this.particleSize, 0, Math.PI * 2);
                canvasContext.fill();
            }
        }

        function spawnNewParticleCloud() {
            // Random spawn point in upper-left area
            const spawnX = Math.random() * 170;
            const spawnY = Math.random() * 170;

            const particlesInCloud = 100;
            const cloudSpreadRadius = 40;

            for (let i = 0; i < particlesInCloud; i++) {
                const randomAngle = Math.random() * 2 * Math.PI;
                const randomRadius = Math.random() * cloudSpreadRadius;
                const particleX = spawnX + Math.cos(randomAngle) * randomRadius;
                const particleY = spawnY + Math.sin(randomAngle) * randomRadius;

                activeParticles.push(new FlowingParticle(particleX, particleY));
            }
        }

        function renderVectorFieldArrows() {
            const gridSize = 40;

            // Soft blue arrows with transparency
            canvasContext.globalAlpha = 0.6;
            canvasContext.strokeStyle = '#ffffff';
            canvasContext.fillStyle = '#ffffff';
            canvasContext.lineWidth = 1.5;

            for (let x = gridSize/2; x < canvasW; x += gridSize) {
                for (let y = gridSize/2; y < canvasH; y += gridSize) {
                    const fieldVector = computeFieldVector(x, y);

                    const arrowScale = 15;
                    const arrowTipX = x + fieldVector.x * arrowScale;
                    const arrowTipY = y + fieldVector.y * arrowScale;

                    // Draw arrow shaft
                    canvasContext.beginPath();
                    canvasContext.moveTo(x, y);
                    canvasContext.lineTo(arrowTipX, arrowTipY);
                    canvasContext.stroke();

                    // Draw arrowhead
                    const direction = Math.atan2(fieldVector.y, fieldVector.x);
                    canvasContext.save();
                    canvasContext.translate(arrowTipX, arrowTipY);
                    canvasContext.rotate(direction);
                    canvasContext.beginPath();
                    canvasContext.moveTo(0, 0);
                    canvasContext.lineTo(-5, -2.5);
                    canvasContext.lineTo(-5, 2.5);
                    canvasContext.closePath();
                    canvasContext.fill();
                    canvasContext.restore();
                }
            }

            canvasContext.globalAlpha = 1.0;
        }

        function executeAnimationFrame() {
            if (!isAnimationRunning) { return; }

            const currentTime = Date.now();
            const totalElapsed = currentTime - animationBeginTime;

            // Stop animation when duration complete
            if (totalElapsed >= animationDurationMs) {
                completeAnimation();
                return;
            }// Spawn exactly 4 clouds within first 30s
            while (cloudsSpawned < cloudSchedule.length && totalElapsed >= cloudSchedule[cloudsSpawned]) {
                spawnNewParticleCloud();
                cloudsSpawned++;
            }

            // Fade effect: draw semi-transparent rectangle over entire canvas
            // This creates trailing effect without storing trail points
            // Lower alpha for smoother, less pixelated trails
            canvasContext.fillStyle = 'rgba(127, 174, 186, 0.05)';
            canvasContext.fillRect(0, 0, canvasW, canvasH);

            // Draw vector field
            // renderVectorFieldArrows();

            // Update and render all particles
            activeParticles = activeParticles.filter(particle => {
                const stillActive = particle.updateParticle();
                if (stillActive) {
                    particle.renderParticle();
                }
                return stillActive;
            });

            requestAnimationFrame(executeAnimationFrame);
        }

        function startNewAnimation() {
            isAnimationRunning = true;
            animationBeginTime = Date.now();
            cloudsSpawned = 0;
            activeParticles = [];
            // Clear canvas with background color
            canvasContext.fillStyle = '#7FAEBA';
            canvasContext.fillRect(0, 0, canvasW, canvasH);
            executeAnimationFrame();
        }
        function completeAnimation() { isAnimationRunning = false; setTimeout(startNewAnimation, 0); }

        // Attach event handlers
        // Initialize display
        renderVectorFieldArrows();
        startNewAnimation();
    </script>
</body>
</html>
