<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Particle in Magnetic Field</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body { width: 100%; height: 100%; overflow: hidden; }
    #container { position: relative; width: 100%; height: 100%; }
    canvas { display: block; position: absolute; top: 0; left: 0; }
  </style>
</head>
<body>
<div id="container">
  <canvas id="fieldCanvas"></canvas>
  <canvas id="particleCanvas"></canvas>
</div>

<script>
  const fieldCanvas = document.getElementById('fieldCanvas');
  const particleCanvas = document.getElementById('particleCanvas');
  const fieldCtx = fieldCanvas.getContext('2d');
  const particleCtx = particleCanvas.getContext('2d');

  const fieldGridSize = 20;
  let magneticField = [];
  let particle;
  let cachedFieldImageData = null;

  function resizeCanvas() {
    const width = window.innerWidth;
    const height = window.innerHeight;

    fieldCanvas.width = width;
    fieldCanvas.height = height;
    fieldCanvas.style.width = width + 'px';
    fieldCanvas.style.height = height + 'px';

    particleCanvas.width = width;
    particleCanvas.height = height;
    particleCanvas.style.width = width + 'px';
    particleCanvas.style.height = height + 'px';

    // Invalidate cache on resize
    cachedFieldImageData = null;
  }

  class Particle {
    constructor(x, y, vx, vy, charge = 1, mass = 1) {
      this.x = x;
      this.y = y;
      this.vx = vx;
      this.vy = vy;
      this.charge = charge;
      this.mass = mass;
    }

    update(dt) {
      const width = particleCanvas.width;
      const height = particleCanvas.height;

      // Interpolated B at current position (scalar Bz)
      const B = getMagneticFieldInterpolated(this.x, this.y);

      // Energy-preserving rotation update for pure magnetic force
      // omega = qB/m, rotate velocity by theta = omega * dt
      let theta = (this.charge * B / this.mass) * dt;

      // Optional clamp to keep per-step rotation stable
      const maxTheta = 0.25;
      if (theta >  maxTheta) theta =  maxTheta;
      if (theta < -maxTheta) theta = -maxTheta;

      if (theta !== 0) {
        const c = Math.cos(theta);
        const s = Math.sin(theta);
        const vx = this.vx, vy = this.vy;
        this.vx =  c * vx - s * vy;
        this.vy =  s * vx + c * vy;
      }

      // Position update
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      // Reflective boundaries
      if (this.x < 0) { this.x = 0; this.vx = -this.vx; }
      if (this.x > width)  { this.x = width;  this.vx = -this.vx; }
      if (this.y < 0) { this.y = 0; this.vy = -this.vy; }
      if (this.y > height) { this.y = height; this.vy = -this.vy; }
    }

    draw() {
      particleCtx.fillStyle = 'black';
      particleCtx.beginPath();
      particleCtx.arc(this.x, this.y, 6, 0, Math.PI * 2);
      particleCtx.fill();
    }
  }

  function generateMagneticField() {
    magneticField = [];
    for (let i = 0; i < fieldGridSize; i++) {
      magneticField[i] = [];
      for (let j = 0; j < fieldGridSize; j++) {
        const x = i / fieldGridSize;
        const y = j / fieldGridSize;

        const field =
          Math.sin(x * Math.PI * 3) * Math.cos(y * Math.PI * 2) *
          Math.exp(-((x - 0.5) ** 2 + (y - 0.3) ** 2) * 3) +
          0.3 * Math.sin(x * Math.PI * 6) * Math.sin(y * Math.PI * 4);

        magneticField[i][j] = field;
      }
    }
  }

  // Bilinear interpolation of the field at (x, y)
  function getMagneticFieldInterpolated(x, y) {
    const width = fieldCanvas.width;
    const height = fieldCanvas.height;

    const fx = (x / width) * (fieldGridSize - 1);
    const fy = (y / height) * (fieldGridSize - 1);

    const x1 = Math.max(0, Math.min(fieldGridSize - 1, Math.floor(fx)));
    const y1 = Math.max(0, Math.min(fieldGridSize - 1, Math.floor(fy)));
    const x2 = Math.min(x1 + 1, fieldGridSize - 1);
    const y2 = Math.min(y1 + 1, fieldGridSize - 1);

    const wx = fx - x1;
    const wy = fy - y1;

    const f11 = magneticField[x1][y1];
    const f21 = magneticField[x2][y1];
    const f12 = magneticField[x1][y2];
    const f22 = magneticField[x2][y2];

    const f1 = f11 * (1 - wx) + f21 * wx;
    const f2 = f12 * (1 - wx) + f22 * wx;
    return f1 * (1 - wy) + f2 * wy;
  }

  function drawMagneticField() {
    const width = fieldCanvas.width;
    const height = fieldCanvas.height;
    if (width <= 0 || height <= 0) return;

    // Use cached image data if available
    if (cachedFieldImageData &&
        cachedFieldImageData.width === width &&
        cachedFieldImageData.height === height) {
      fieldCtx.putImageData(cachedFieldImageData, 0, 0);
      return;
    }

    const imageData = fieldCtx.createImageData(width, height);
    const data = imageData.data;

    let minField = Infinity;
    let maxField = -Infinity;
    for (let i = 0; i < fieldGridSize; i++) {
      for (let j = 0; j < fieldGridSize; j++) {
        minField = Math.min(minField, magneticField[i][j]);
        maxField = Math.max(maxField, magneticField[i][j]);
      }
    }
    const denom = (maxField - minField) || 1;

    for (let y = 0; y < height; y++) {
      for (let x = 0; x < width; x++) {
        const fx = (x / width) * (fieldGridSize - 1);
        const fy = (y / height) * (fieldGridSize - 1);

        const x1 = Math.floor(fx);
        const x2 = Math.min(x1 + 1, fieldGridSize - 1);
        const y1 = Math.floor(fy);
        const y2 = Math.min(y1 + 1, fieldGridSize - 1);

        const wx = fx - x1;
        const wy = fy - y1;

        const f11 = magneticField[x1][y1];
        const f21 = magneticField[x2][y1];
        const f12 = magneticField[x1][y2];
        const f22 = magneticField[x2][y2];

        const f1 = f11 * (1 - wx) + f21 * wx;
        const f2 = f12 * (1 - wx) + f22 * wx;
        const field = f1 * (1 - wy) + f2 * wy;

        const normalized = (field - minField) / denom;

        const baseColor = { r: 127, g: 174, b: 186 };
        const intensity = normalized;

        const r = Math.floor(baseColor.r + (255 - baseColor.r) * intensity);
        const g = Math.floor(baseColor.g + (255 - baseColor.g) * intensity);
        const b = Math.floor(baseColor.b + (255 - baseColor.b) * intensity);

        const index = (y * width + x) * 4;
        data[index] = r;
        data[index + 1] = g;
        data[index + 2] = b;
        data[index + 3] = 255;
      }
    }

    fieldCtx.putImageData(imageData, 0, 0);
    cachedFieldImageData = imageData; // Cache for future frames
  }

  function animate(now) {
    if (!animate.last) animate.last = now;
    // dt in seconds, cap to keep stable
    const dt = Math.min(0.03, Math.max(0.001, (now - animate.last) / 1000));
    animate.last = now;

    const width = particleCanvas.width;
    const height = particleCanvas.height;
    if (width > 0 && height > 0) {
      // Only clear and redraw particle canvas
      particleCtx.clearRect(0, 0, width, height);
      particle.update(dt);
      particle.draw();
    }

    requestAnimationFrame(animate);
  }

  function init() {
    resizeCanvas();
    generateMagneticField();
    drawMagneticField(); // Draw field once at start
    particle = new Particle(particleCanvas.width * 0.25, particleCanvas.height * 0.25, 500, 250, 4, 1);
    requestAnimationFrame(animate);
  }

  window.addEventListener('resize', () => {
    const oldWidth = particleCanvas.width;
    const oldHeight = particleCanvas.height;
    resizeCanvas();
    drawMagneticField(); // Redraw field on resize
    if (particle && oldWidth > 0 && oldHeight > 0) {
      particle.x = (particle.x / oldWidth) * particleCanvas.width;
      particle.y = (particle.y / oldHeight) * particleCanvas.height;
    }
  });

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', init);
  } else {
    init();
  }
</script>
</body>
</html>
